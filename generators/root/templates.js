var generators = [];

generators.push({
    name: 'page',
    version: '0.1',
    code: function(data, templates) {
        // The below could be concatUIE template
        data.body = expand(data.body);
        data.head = data.head;
        data.inclString = '<% include modeldefs %>';// this include statement needs to be inserted into the generated code but it was causing problems inside the template and idk how to escape it in EJS.
        return templates.code(data);
    },
    templates: {'code':"<html>\n \
    <head>\n \
\
    <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"></script>\
\
    <!-- begin autogenerated api client library --> \
    <script type=\"text/javascript\"><%- inclString %></script>\n \
    <script src=\"/static/models.js\"></script> \
    <!-- end autogenerated api client library --> \
    <%- head %>\n \
    </head>\n \
    <body>\n \
    <%- body %>\n \
    </body>\n \
</html>\n" }
});

generators.push({
    name: 'concatUIE',
    version: '0.1',
    code: function(data, templates){
        // CSS at the top, then HTML elements, then the corresponding Javascript at the bottom.
        // TODO add some marks/tags to make it easier to find code for debugging.
        var templateLines = [];
        var i, uie;
        for (i = 0; i < data.length; i ++) {
            uie = data[i];
            data[i] = expand(uie);
        }
        for (i = 0; i < data.length; i ++) {
            uie = data[i];
            if (uie.css) templateLines.push("<style>"+uie.css+"</style>");
        }
        for (i = 0; i < data.length; i ++) {
            uie = data[i];
            templateLines.push(uie.html);
        }
        for (i = 0; i < data.length; i ++) {
            uie = data[i];
            if (uie.js) templateLines.push('<script type="text/javascript">'+uie.js+'</script>');
        }

        return templateLines.join("\n");
    },
    templates: {'code':""}
});

generators.push({
    name: 'rowcolUIE',
    version: '0.1',
    code: function(data, templates) {
        
        function split_to_cols(uielements, leftOffset) {
            // """Given some uielements, separate them into non-overlapping columns"""

            var cols = [];
            if (uielements.length === 0) {
                return cols;
            }

            sorted_uiels = uielements.sort(function(a,b) { return a.layout.left - b.layout.left; });

            // # leftmost uiel must be in the row
            var current_col = {};
            current_col.uiels = [];

            cols.push(current_col);
            current_block = sorted_uiels.pop();
            current_col.uiels.push(current_block);
            current_col.margin_left = current_block.layout.left - leftOffset;

            // # iterate over the uiels left down
            sorted_uiels.forEach(function(u) {
                current_right = current_block.layout.left + current_block.layout.width;
                u_left = u.layout.left;
                u_right = u_left + u.layout.width;

                // # Two cases:
                // # 1. this block is in the current row.
                if (u_left < current_right) {
                    current_col.uiels.push(u);
                        // # a. this block is extends longer than the current block
                    if (u_right > current_right) current_block = u;
                }
                // # 2. this block must be the left-most block in a new row
                else {
                    current_col.width = current_right - current_col.uiels[0].layout.left;

                    current_col = {};
                    cols.push(current_col);

                    current_col.uiels.push(u);
                    current_col.margin_left = u_left - current_right;

                    current_block = u;
                }
            });
            // # set the width of the last column
            current_right = current_block.layout.left + current_block.layout.width;
            current_col.width = current_right - current_col.uiels[0].layout.left;

            return cols;
        }

        function split_to_rows(uielements, topOffset) {

            var rows = [];

            if (uielements.length === 0) {
                return rows;
            }

            var sorted_uiels = uielements.sort(function(a,b) { return a.layout.top - b.layout.top; });

            // topmost uiel must be in the row
            var current_row = {};
            rows.push(current_row);
            current_block = sorted_uiels.pop();

            current_row.uiels = (current_row.uiels || []);
            current_row.uiels.push(current_block);
            current_row.margin_top = current_block.layout.top - topOffset;

            // iterate over the uiels top down
            sorted_uiels.forEach(function(u) {

                current_bottom = current_block.layout.top + current_block.layout.height;
                u_top = u.layout.top;
                u_bottom = u_top + u.layout.height;

                // Two cases:
                // 1. this block is in the current row.
                if (u_top < current_bottom) {
                    current_row.uiels.push(u);
                        // # a. this block is extends longer than the current block
                    if (u_bottom > current_bottom) current_block = u;
                // 2. this block must be the top-most block in a new row
                }
                else {
                    current_row = {};
                    rows.push(current_row);

                    current_row.uiels.push(u);
                    current_row.margin_top = u_top - current_bottom;

                    current_block = u;
                }
            });

            return rows;
        }

        function createTree(uielements, nmrRecursion, topOffset, leftOffset) {

            var rows = split_to_rows(uielements, topOffset);

            rows.forEach(function(row) {

                var columns = split_to_cols(row.uiels, leftOffset);
                row.cols = columns;

                var topOffset = (row.uiels[0].layout.top||0);

                columns.forEach(function(column) {

                    var leftOffset = column.uiels[0].layout.left;
                    
                    if (column.uiels.length == 1) {
                        column.marginTop = (column.uiels[0].layout.top||0) - topOffset;
                        return;
                    }
                    else {
                        if (rows.length == 1 && columns.length == 1) {
                            // in this case, recursion will not terminate since input is not subdivided into smaller components
                            // create a relative container and absolute position the
                            // contents.
                            column.uiels[0].layout = (column.uiels[0].layout || {});

                            var min_top = (column.uiels[0].layout.top||0);
                            var max_bottom = (column.uiels[0].layout.top||0) + column.uiels[0].layout.height;
                            
                            column.uiels.forEach(function(uie) {
                                uie.layout = (uie.layout || {});
                                var top_offset = (uie.layout.top||0) - topOffset;
                                var left_offset = uie.layout.left - leftOffset;
                                uie.overlap_styles = "; position: absolute; top: %spx; left: %spx;" % (
                                    15 * top_offset, 80 * left_offset);
                                var min_top = Math.min(uie.layout.top, min_top);
                                var max_bottom = Math.max(uie.layout.top + uie.layout.height, max_bottom);
                            });

                            column.has_overlapping_nodes = true;

                            column.container_height = max_bottom - min_top;

                            column.tree = null;
                        }
                        else {
                            column.tree = createTree(column.uiel,s, topOffset, leftOffset, nmrRecursion+ 1);
                        }
                    }
                });
            });

            return { rows: rows };

        }

        var domTree = createTree(data, 0, 0, 0);

        console.log(domTree);

        var cssLines = [];
        var jsLines = [];
        var htmlLines = [];

        var nodeLines = [];

        function rowLoop(rows) {
            domTree.rows.forEach(function(row) {
                if(row.cols) {
                    htmlLines.push('<div class="row">');

                    row.cols.forEach(function(col) {
                        if(col.tree) {
                            rowLoop(col.tree.rows);
                        }
                        else {
                            htmlLines.push('SOME ELEMENT HERE');
                        }
                    });

                    htmlLines.push('</div>');
                }
            });
        }

        rowLoop(domTree.rows);

        // for (i = 0; i < data.length; i ++) {
        //     uie = data[i];
        //     if (uie.css) templateLines.push("<style>"+uie.css+"</style>");
        // }
        // for (i = 0; i < data.length; i ++) {
        //     uie = data[i];
        //     templateLines.push(uie.html);
        // }
        // for (i = 0; i < data.length; i ++) {
        //     uie = data[i];
        //     if (uie.js) templateLines.push('<script type="text/javascript">'+uie.js+'</script>');
        // }

        return htmlLines.join("\n");
    },
    templates: {'code':""}

});
exports.generators = generators;
